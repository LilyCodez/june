import std.os.Win32;
import std.lang.String;
import std.io.File;
import std.io.FileFlags;
import std.Sys;

InStream :: record {
	
	handle :void*;

	InStream(handle :void*) {
		this.handle = handle;
	}

	InStream(file :File) {
		
		accessFlags := 0u;
		shareFlags  := 0u;
		createFlags := 0u;
		
		if file.flags == 0 {
			accessFlags = Win32.GENERIC_ALL;
		}
		
		if (file.flags & FileFlags.IN) != 0 {
			accessFlags |= Win32.GENERIC_READ;
		}
		
		if (file.flags & FileFlags.OUT) != 0 {
			accessFlags |= Win32.GENERIC_WRITE;
		}
		
		if (file.flags & FileFlags.SHARE) != 0 {
			shareFlags |= Win32.FILE_SHARE_READ;
		}
		
		if (file.flags & FileFlags.CREATE) != 0 {
			createFlags |= Win32.CREATE_NEW;
		} else {
			createFlags |= Win32.OPEN_EXISTING;
		}
		
		handle = Win32.CreateFileA(file.path,
		                           accessFlags,
								   shareFlags,
								   null,
								   createFlags,
								   Win32.FILE_ATTRIBUTE_NORMAL,
								   null);
		
		if handle == Win32.INVALID_HANDLE_VALUE {
			// TODO: Actual error handling
			Sys.println("Failed to open file");
			Sys.exit(1);
		}
	}

	read(buffer :c8*, len :u32) -> u32 {
		numberOfBytersRead :u32;
		Win32.ReadFile(handle, buffer, len, &numberOfBytersRead, null);
		return numberOfBytersRead;
	}

	readLine() -> String {
		buffer :c8[1024];
		amountRead :i32 = read(buffer, buffer.length);
		// -2 because \r\n
		return String(buffer, amountRead - 2);
	}

	readInt() -> i32 {
		return readLine().parseInt();
	}

	close() {
		Win32.CloseHandle(handle);
	}
}