import std.Mem;
import std.Sys;
import std.lang.Characters;
import std.Err;
import std.ErrKind;

/*
 * The smallest possible radix for converting to/from strings
 * into numbers.
 */
comptime MIN_RADIX := 2;

/*
 * The largest possible radix for converting to/from strings
 * into numbers.
 */
comptime MAX_RADIX := 36;

String :: record {

	length: u32;
	buffer: c8*;

	String() {}

	String(buffer: c8*) {
		this.length = Mem.strlen(buffer);
		this.buffer = new c8[length + 1]; // +1 for null terminator
		Mem.memcpy(this.buffer, buffer, length + 1);
	}

	String(buffer: c8*, length: u32) {
		this.length = length;
		this.buffer = new c8[length + 1]; // +1 for null terminator
		Mem.memcpy(this.buffer, buffer, length);
		this.buffer[length] = '\0';
	}

	/*
	 * Parses the string into a signed integer width
	 * a radix of 10 (Base-10).
	 *
	 * Valid character pattern: [+-]?[0-9]+
	 *
	 * @return  a parsed signed integer.
	 */
	parseInt() -> (i32, Err) {
		return parseInt(10);
	}

	/*
	 * Parses the string into a signed integer
	 * for the given radix. All the characters in
	 * the string (excluding a leading + or -)
	 * must all be digits of the given radix.
	 *
	 * @param   radix to be used during parsing
	 * @return  a parsed signed integer.
	 */
	parseInt(radix: u32) -> (i32, Err) {
		
		if (empty()) {
			return (0, Err(ErrKind.NUMBER_FORMAT, "empty string"));
		}

		if radix < MIN_RADIX {
			return (0, Err(ErrKind.NUMBER_FORMAT, "radix < 2"));
		}

		if radix > MAX_RADIX {
			return (0, Err(ErrKind.NUMBER_FORMAT, "radix too large"));
		}

		isNeg := false;
		i := 0;

		// Maybe it has a leading + or -
		firstCh: c8 = buffer[0];
		if firstCh < '0' {
			if firstCh == '-' {
				isNeg = true;
			} else if firstCh != '+' {
				return (0, Err(ErrKind.NUMBER_FORMAT, "Invalid sequence start"));
			}

			if length == 1 {
				return (0, Err(ErrKind.NUMBER_FORMAT, "+ or - by itself"));
			}

			++i; // Move over the + or - character
		}
		
		result: i32;  prevVal: i32;
		loop i < length {
			ch := buffer[i++];
			digit :i32 = Characters.toDigitForRadix(ch, radix);

			if digit < 0 {
				return (0, Err(ErrKind.NUMBER_FORMAT, "Character was not a digit"));
			}

			prevVal = result;
			result = result * radix + digit;

			if result / radix < prevVal {
				return (0, Err(ErrKind.NUMBER_FORMAT, "Overflow"));
			}
		}

		return (isNeg ? -result |> result, Err.ok());
	}

	empty() -> bool {
		return length == 0;
	}

	~String() {
		delete buffer;
	}
}

from(i: i32) -> String {
	if i == 0 {
		return String("0");
	}

	res := String();
	isNeg: bool = i < 0;
	
	if isNeg { ++res.length; }
	else     { i = -i;       }
	
	iCount: i32 = i;
	loop iCount < 0 {
		iCount /= 10;
		++res.length;
	}
	
	res.buffer = new c8[res.length + 1];
	scan: i32 = res.length - 1;
	loop i < 0 {
		res.buffer[scan--] = cast(c8)(-(i % 10)) + '0';
		i /= 10;
	}
	
	if isNeg {
		res.buffer[scan] = '-';
	}
	
	res.buffer[res.length] = '\0';
	return res;
}

concat(a: String*, b: String*) -> String {
	newString := String();

	newString.length = a.length + b.length;
	newString.buffer = new c8[newString.length];
	Mem.memcpy(newString.buffer, a.buffer, a.length);
	Mem.memcpy(newString.buffer + a.length, b.buffer, b.length);

	return newString;
}