#include "Compiler.h"
#include "Logger.h"

#include <llvm/Support/raw_ostream.h>

const char* HELP_MESSAGE =
R"(Usage: june <sources> <options>
Possible Options:
    -display.times
       Displays how long different stages took.
    -verbose
       Display more verbose details about what the compiler
       is doing.
    -display.ast
       Displays the abstract syntax tree generated by the
       parser.
    -stand.alone
       Excludes compiling with the standard library.
    -emit.debug
       Emits debug information.
    -out.name=<name>
       Sets the name of the executable.
    -l<Library>
       Adds a library to the linker.
    -L<libpath>
       Adds a path to search for libraries in.

Sources:
   Sources may either be absolute paths to a file or
   a directory in which case all .june files within the
   directory and sub-directories will be included.
)";

int main(int argc, char* argv[]) {

	june::Compiler C;

	
	llvm::SmallVector<const c8*, 1> SourceDirectories;
	
	bool ErrorFound = false, RequestedHelpMsg = false;
	for (int i = 1; i < argc; i++) {
		if (argv[i][0] == '-') {
			llvm::StringRef Opt =
				llvm::StringRef(argv[i] + 1);
			
			if (Opt == "display.times") {
				C.DisplayTimes = true;
			} else if (Opt == "verbose") {
				C.Verbose = true;
			} else if (Opt == "display.llvm") {
				C.DisplayLLVMIR = true;
			} else if (Opt == "display.ast") {
				C.DisplayAST = true;
			} else if (Opt == "stand.alone") {
				C.StandAlone = true;
			} else if (Opt == "emit.debug") {
				C.EmitDebugInfo = true;
			} else if (Opt == "help") {
				llvm::outs() << HELP_MESSAGE << '\n';
				return 0;
			} else if (Opt.empty()) {
				june::Logger::GlobalError(llvm::outs(), "empty option");
				ErrorFound = true;
			} else if (Opt.startswith("l")) {
				// TODO: Check for empty library name
				C.AddLib(Opt.substr(1).data());
			} else if (Opt.startswith("L")) {
				// TODO: Check for empty library path
				C.AddLibPath(Opt.substr(1).data());
			} else if (Opt.startswith("out.name")) {
				llvm::StringRef ValPart = Opt.substr(8);
				if (ValPart.empty() || ValPart[0] != '=') {
					june::Logger::GlobalError(llvm::outs(), "Expected '=' for out.name option");
					ErrorFound = true;
					continue;
				}
				ValPart = ValPart.substr(1);
				if (ValPart.empty()) {
					june::Logger::GlobalError(llvm::outs(), "Missing value for out.name option");
					ErrorFound = true;
					continue;
				}
				C.SetOutputName(std::string(ValPart.data()));
			} else {
				// TODO: Underline and show which option
				june::Logger::GlobalError(llvm::outs(), "Unknown option");
				ErrorFound = true;
			}
		} else {
			SourceDirectories.push_back(argv[i]);
		}
	}

	if (ErrorFound) {
		return 1;
	}

	if (SourceDirectories.empty()) {
		june::Logger::GlobalError(llvm::errs(), "No source directories provided");
		return 1;
	}

	C.Compile(SourceDirectories);

	return 0;
}